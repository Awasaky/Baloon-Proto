local do_math = require("assets.scripts.do_math")

-- Script inside constants
local const = {
	height_ceil = 10000,
	height_floor = 100,
	ascent_lift = 600,
	ascent_speed = 250,
	descent_lift = -400,
	descent_speed = -200,
	temp_ceil = -35,
	temp_floor = 0,
	back_dist = 3600,
	back_start = 900,
	back_width = 7680,
	pix_coef = 00,
	speed_save = 0.75
}

-- Script inside variables
local vars = {
	height_start = 1000,
	lift_state = "idle", -- possible "ascent", "descent",
	temp_today = 15,
	ballon_temp = 00,
	back_speed = {},
	prev_speed = 00,
	traveled_dist = 00,
	prev_x = 00,
	set_vert_speed = 00
}

go.property("height", 00)

function init(self)
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	self.height = vars.height_start -- later maybe another height
	msg.post("/clouds#clouds", "constants", {
		height_ceil = const.height_ceil,
		height_floor = const.height_floor,
		back_dist = const.back_dist,
		back_start = const.back_start
	})
	const.pix_coef = (const.height_ceil - const.height_floor) / const.back_dist -- m/pix
end

function on_message(self, message_id, message, sender)
	if message_id == hash("collision_response") then
		local full_url = msg.url(message.other_id)
		full_url.fragment = "cloud"
		vars.back_speed[#vars.back_speed + 1] = go.get(full_url, "speed")
	elseif message_id == hash("lift_down") then
		vars.lift_state = "descent"
	elseif message_id == hash("lift_up") then
		vars.lift_state = "ascent"
	elseif message_id == hash("lift_stop") then
		vars.lift_state = "idle"
	end
end

function update(self, dt)
	local speed_change = 0
	if vars.lift_state == "ascent" then
		speed_change = const.ascent_speed
	elseif vars.lift_state == "descent" then
		speed_change = const.descent_speed
	elseif vars.lift_state == "idle" then
		if vars.set_vert_speed > const.ascent_speed * dt then
			speed_change = -const.ascent_speed
		elseif vars.set_vert_speed < const.descent_speed * dt then
			speed_change = -const.descent_speed
		end
	end
	vars.set_vert_speed = vars.set_vert_speed + speed_change * dt
	vars.set_vert_speed = do_math.clamp_number(vars.set_vert_speed, const.ascent_lift, const.descent_lift)
	self.height = self.height + vars.set_vert_speed * dt

	--used to repos back
	local height_coef = do_math.rev_lerp_number(self.height, const.height_ceil, const.height_floor)

	--update temp
	vars.ballon_temp = vars.temp_today + do_math.lerp_number(height_coef, const.temp_ceil, const.temp_floor)

	-- reposition back vec2 depended by height
	local back_pos = go.get_position("/back")
	--back_pos.x
	local cumulative_speed = do_math.average(vars.back_speed)
	vars.back_speed = {} -- reset table to next frame
	cumulative_speed = do_math.lerp_number(const.speed_save, cumulative_speed, vars.prev_speed)
	vars.prev_speed = cumulative_speed
	back_pos.x = back_pos.x - cumulative_speed * const.pix_coef * dt / 40
	-- back reposition
	if back_pos.x > const.back_width * 0.5 then back_pos.x = back_pos.x - const.back_width
	elseif back_pos.x < const.back_width * -1.5 then back_pos.x = back_pos.x + const.back_width
	end
	vars.traveled_dist = vars.traveled_dist - ( back_pos.x - vars.prev_x ) * const.pix_coef
	vars.prev_x = back_pos.x
	back_pos.y = const.back_start - const.back_dist * height_coef
	go.set_position(back_pos, "/back")
	--reposition clouds
	go.set("/clouds#clouds", "height", self.height)

	--update gui
	msg.post("/gui#generic", "hud", {
		height = self.height,
		temp = vars.ballon_temp,
		dist = vars.traveled_dist
	})
end