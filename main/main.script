local do_math = require("assets.scripts.do_math")

-- Script inside constants
local const = {
	height_ceil = 10000,
	height_floor = 100,
	ascent_lift = 500,
	ascent_time = 3.5,
	descent_lift = -350,
	descent_time = 1.0,
	temp_ceil = -35,
	temp_floor = 0,
	back_dist = 3600,
	back_start = 900,
	back_width = 7680,
	pix_coef = 00,
	speed_save = 0.75
}

-- Script inside variables
local variables = {
	height_start = 1000,
	lift_state = "idle",
	temp_today = 15,
	ballon_temp = 00,
	back_speed = {},
	prev_speed = 00,
	traveled_dist = 00,
	last_x = 00
}

function init(self)
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	--Animable variables
	go.property("height", 0)
	self.height = variables.height_start
	msg.post("/clouds#clouds", "positioning", {
		height_ceil = const.height_ceil,
		height_floor = const.height_floor,
		back_dist = const.back_dist,
		back_start = const.back_start
	})
	const.pix_coef = (const.height_ceil - const.height_floor) / const.back_dist
end

local function lift_cancel()
	variables.lift_state = "idle"
	go.cancel_animations("#", "height")
end

function on_message(self, message_id, message, sender)
	if message_id == hash("lift_down") then
		if variables.lift_state == "idle" then
			variables.lift_state = "descent"
			local new_height = self.height + const.descent_lift
			go.animate("#","height", go.PLAYBACK_ONCE_FORWARD, new_height, go.EASING_LINEAR, const.descent_time, 0, lift_cancel)
		else
			lift_cancel()
		end
	elseif message_id == hash("lift_up") then
		lift_cancel()
		variables.lift_state = "ascent"
		local new_height = self.height + const.ascent_lift
		go.animate("#","height", go.PLAYBACK_ONCE_FORWARD, new_height, go.EASING_OUTCIRC, const.ascent_time, 0, lift_cancel)
	elseif message_id == hash("collision_response") then
		local full_url = msg.url(message.other_id)
		full_url.fragment = "cloud"
		variables.back_speed[#variables.back_speed+1] = go.get(full_url, "speed") --??
	end
end

function update(self, dt)
	local height_coef = do_math.rev_lerp_number(self.height, const.height_ceil, const.height_floor)

	--update temp
	variables.ballon_temp = variables.temp_today + do_math.lerp_number(height_coef, const.temp_ceil, const.temp_floor)

	-- reposition back vec2 depended by height
	local back_pos = go.get_position("/back")
	--back_pos.x
	local cumulative_speed = do_math.average(variables.back_speed)
	variables.back_speed = {} -- reset table to next frame
	cumulative_speed = do_math.lerp_number(const.speed_save, cumulative_speed, variables.prev_speed)
	back_pos.x = back_pos.x - cumulative_speed * const.pix_coef * dt / 40
	-- back reposition
	if back_pos.x > const.back_width * 0.5 then back_pos.x = back_pos.x - const.back_width
	elseif back_pos.x < const.back_width * -1.5 then back_pos.x = back_pos.x + const.back_width
	end
	variables.prev_speed = cumulative_speed
	variables.traveled_dist = variables.traveled_dist - ( back_pos.x - variables.last_x ) * const.pix_coef
	variables.last_x = back_pos.x
	back_pos.y = const.back_start - const.back_dist * height_coef
	go.set_position(back_pos, "/back")	
	--reposition clouds
	go.set("/clouds#clouds", "height", self.height)

	--update gui
	msg.post("/gui#generic", "hud", {
		height = self.height,
		temp = variables.ballon_temp,
		dist = variables.traveled_dist
	})
end